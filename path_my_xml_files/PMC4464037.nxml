<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article" xml:lang="en"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id><journal-title-group><journal-title>BMC Bioinformatics</journal-title></journal-title-group><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">26051265</article-id><article-id pub-id-type="pmc">4464037</article-id><article-id pub-id-type="publisher-id">1471-2105-16-S9-S4</article-id><article-id pub-id-type="doi">10.1186/1471-2105-16-S9-S4</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>Fast randomized approximate string matching with succinct hash data structures</article-title></title-group><contrib-group><contrib contrib-type="author" id="A1"><name><surname>Policriti</surname><given-names>Alberto</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref></contrib><contrib contrib-type="author" corresp="yes" id="A2"><name><surname>Prezza</surname><given-names>Nicola</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>prezza.nicola@spes.uniud.it</email></contrib></contrib-group><aff id="I1"><label>1</label>Department of Mathematics and Informatics, University of Udine, via delle Scienze, 33100, Udine, Italy</aff><aff id="I2"><label>2</label>Institute of Applied Genomics, via J. Linussio, 33100 Udine, Italy</aff><pub-date pub-type="collection"><year>2015</year></pub-date><pub-date pub-type="epub"><day>1</day><month>6</month><year>2015</year></pub-date><volume>16</volume><issue>Suppl 9</issue><supplement><named-content content-type="supplement-title">Proceedings of the Italian Society of Bioinformatics (BITS): Annual Meeting 2014: Bioinformatics</named-content><named-content content-type="supplement-editor">Angelo Facchiano</named-content><named-content content-type="supplement-sponsor">Publication of this supplement has not been supported by sponsorship. Information about the source of funding for publication charges can be found in the individual articles. Articles have been through the journal's standard peer review process for supplements. The Supplement Editor declares that he has no competing interests.</named-content></supplement><fpage>S4</fpage><lpage>S4</lpage><permissions><copyright-statement>Copyright &#x000a9; 2015 Policriti and Prezza et al.; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2015</copyright-year><copyright-holder>Policriti and Prezza et al.; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/4.0"><license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0">http://creativecommons.org/licenses/by/4.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p></license></permissions><self-uri xlink:href="http://www.biomedcentral.com/1471-2105/16/S9/S4"/><abstract><sec><title>Background</title><p>The high throughput of modern NGS sequencers coupled with the huge sizes of genomes currently analysed, poses always higher algorithmic challenges to align short reads quickly and accurately against a reference sequence. A crucial, additional, requirement is that the data structures used should be <italic>light</italic>. The available modern solutions usually are a compromise between the mentioned constraints: in particular, indexes based on the Burrows-Wheeler transform offer reduced memory requirements at the price of lower sensitivity, while hash-based text indexes guarantee high sensitivity at the price of significant memory consumption.</p></sec><sec><title>Methods</title><p>In this work we describe a technique that permits to attain the advantages granted by both classes of indexes. This is achieved using Hamming-aware hash functions--hash functions designed to search the entire Hamming sphere in reduced time--which are also homomorphisms on de Bruijn graphs. We show that, using this particular class of hash functions, the corresponding hash index can be represented in linear space introducing only a logarithmic slowdown (in the query length) for the lookup operation. We point out that our data structure reaches its goals <italic>without </italic>compressing its input: another positive feature, as in biological applications data is often very close to be un-compressible.</p></sec><sec><title>Results</title><p>The new data structure introduced in this work is called <italic>dB-hash </italic>and we show how its implementation--BW-ERNE--maintains the high sensitivity and speed of its (hash-based) predecessor ERNE, while drastically reducing space consumption. Extensive comparison experiments conducted with several popular alignment tools on both simulated and real NGS data, show, finally, that BW-ERNE is able to attain both the positive features of succinct data structures (that is, small space) and hash indexes (that is, sensitivity).</p></sec><sec><title>Conclusions</title><p>In applications where space and speed are both a concern, standard methods often sacrifice accuracy to obtain competitive throughputs and memory footprints. In this work we show that, combining hashing and succinct indexing techniques, we can attain good performances and accuracy with a memory footprint comparable to that of the most popular compressed indexes.</p></sec></abstract><kwd-group><kwd>Hashing</kwd><kwd>succinct indexing</kwd><kwd>BWT</kwd><kwd>de Bruijn property</kwd><kwd>complexity analysis</kwd></kwd-group><conference><conf-date>26-28 February 2014</conf-date><conf-name>Eleventh Annual Meeting of the Bioinformatics Italian Society Meeting</conf-name><conf-loc>Rome, Italy</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>The advent of New Generation Sequencing (NGS) technologies opened a new era in the field of DNA sequencing, providing researchers with powerful instruments able to produce millions of short (and, lately, long) reads per single run. This technology breakthrough poses considerable computational challenges since the sequenced fragments need to be quickly aligned--usually admitting errors--against genomes whose size is often of the order of giga-bases. From the algorithmic point of view, the problem of indexing texts to support pattern matching in the big-data domain is receiving significant attention, also due to the recent computational breakthroughs in the fields of succinct and compressed text indexes (a typical example is the FM self-index [<xref ref-type="bibr" rid="B1">1</xref>] used nowadays by many aligners, e.g. Bowtie [<xref ref-type="bibr" rid="B2">2</xref>]). Even though these important results solved most of the problems related to <italic>exact </italic>pattern matching, the problem of indexing a text with a succinct--or compressed--data structure that supports <italic>inexact </italic>pattern matching, still represents a considerable challenge. Due to the fact that BWT indexes are natively designed for exact pattern matching, in practice this problem is solved by splitting the pattern in fragments (e.g. using q-grams), searching for all possible variants of the modified pattern (e.g. by backtracking), or mixing the two strategies (hybrid). SOAP2 [<xref ref-type="bibr" rid="B3">3</xref>] adopts the first strategy, splitting the pattern in <italic>k </italic>+ 1 blocks, that is admitting at most <italic>k </italic>errors, and searching for exact occurrences of the blocks. The strategy is then completed by accelerating the search using a hash table to pre-compute backward search results on the BWT reference index. Bowtie [<xref ref-type="bibr" rid="B2">2</xref>] adopts a backtracking strategy on the FM index, inserting a mismatch in correspondence to low-quality bases during backward search. BWA [<xref ref-type="bibr" rid="B4">4</xref>] adopts a backtracking strategy on a BWT-based index that allows to (recursively) retrieve the occurrences of the pattern once an upper bound to the number of admitted mismatches is fixed. ERNE [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B6">6</xref>] implements a hybrid strategy, splitting the pattern in <italic>t </italic>blocks and computing, for each of them, its hash value. The particular class of hash functions employed (Hamming-aware hash function) allows to compute efficiently fingerprints of blocks at Hamming distance at most <italic>k/t </italic>from the original block. These fingerprints are then finally searched in the hash index. We mention also a similar hybrid strategy, based on <italic>perfect Hamming codes</italic>, adopted in [<xref ref-type="bibr" rid="B7">7</xref>].</p><p>One of the strengths of BWT-based tools is their reduced space requirement. The space for the data structure is often close to that required by the reference string (the genome). As an example, Bowtie requires only 2.7GB of RAM to index the Human genome. On the other hand, hash-based tools such as ERNE or SOAP [<xref ref-type="bibr" rid="B8">8</xref>] require much more memory to store their indexes, due to the fact that they need to explicitly memorize pointers to the reference. ERNE and SOAP require 19GB and 14GB of RAM to index the Human genome, respectively.</p><p>From a theoretical point of view, indexing for approximate string matching is still at an early research stage: even the most efficient solutions are, in practice, far from being usable. As a matter of fact, the most advanced results to date are able to guarantee efficiency on <italic>either </italic>space <italic>or </italic>speed. Not both at the same time. Letting <italic>m </italic>and <italic>k </italic>be the query length and the maximum number of allowed errors, respectively, simple backtracking strategies have a complexity that rapidly blows up with a factor of <italic>m<sup>k</sup></italic>: impractical for searching with a reasonable amount of errors on (even not exceedingly) long patterns. Other solutions improve query time by trading on space requirements: letting <italic>n </italic>be the text length, the index of Cole et al. in [<xref ref-type="bibr" rid="B9">9</xref>] solves the problem in time <inline-formula><mml:math id="M1" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>((log <italic>n</italic>)<italic>k </italic>log log <italic>n </italic>+ <italic>m </italic>+ <italic>occ</italic>) and space <inline-formula><mml:math id="M2" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>(<italic>n</italic>(log <italic>n</italic>)<italic><sup>k+1</sup></italic>) bits, which in practice is too much even for small pattern lengths and number of errors. The solution of Chan et al. presented in [<xref ref-type="bibr" rid="B10">10</xref>] improves on space consumption requiring <inline-formula><mml:math id="M3" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>(<italic>n </italic>log <italic>n</italic>) bits, but query time increases to <inline-formula><mml:math id="M4" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>(<italic>m </italic>+ <italic>occ </italic>+ (<italic>c </italic>log <italic>n</italic>)<italic><sup>k(<italic>k</italic>+1) </sup></italic>log log <italic>n</italic>), which exponentially blows up with the <italic>square </italic>of the number of errors.</p><p>We tackled the problem with a hash-based randomized algorithm that is able to reach expected fast performances and requires linear space. The two goals are obtained providing a hash function belonging to two particular classes of hash functions at the same time. The two classes are Hamming-aware and de Bruijn hash functions, respectively. Functions in the former class allow to "squeeze" the Hamming sphere of radius <italic>k </italic>centered at the query pattern <italic>P</italic>, to a Hamming sphere of radius <inline-formula><mml:math id="M5" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>(<italic>k</italic>) centered at the hash value of the query. Functions in the second class (de Bruijn) are homomorphisms on de Bruijn graphs. We show that their corresponding hash indexes can be represented in linear space introducing only a small slowdown of <inline-formula><mml:math id="M6" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>(log <italic>m</italic>) in the lookup operation.</p><p>We call <italic>dB-hash </italic>the resulting <italic>succinct hash </italic>data structure.</p><p>Letting <italic>n </italic>and <italic>m </italic>be the sizes of text and pattern, respectively, our algorithm reaches an expected time complexity of <inline-formula><mml:math id="M7" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>((log <italic>n</italic>)<italic><sup>k</sup></italic>log <italic>m </italic>+ <italic>m</italic>) while requiring <inline-formula><mml:math id="M8" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>(<italic>n </italic>log <italic>&#x003c3;</italic>) bits (<italic>&#x003c3; </italic>being the alphabet size) of space for the index only. Our result extends the strategy presented in [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B6">6</xref>], substituting a standard hash index with the new proposed dB-hash data structure and allowing us to improve on both time and space complexities with respect to [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B6">6</xref>]. Under the hypothesis that the indexed text is perturbed by random noise (e.g. genetic mutations in DNA), our algorithm improves upon theoretical linear-space upper-bounds discussed in the literature (a full formal proof of this can be found in [<xref ref-type="bibr" rid="B11">11</xref>]).</p><p>The resulting algorithm has been implemented in the short-reads aligner BW-ERNE, the natural adaptation of the hash-based ERNE aligner (ERNE-MAP) to the dB-hash data structure. Aim of this paper is to compare the performances of BW-ERNE with those of state-of-the-art short-read aligners. BW-ERNE uses a succinct dB-hash index based on the Burrows-Wheeler transform coupled with wavelet tree and not using any kind of compression (more on this aspect later). Moreover, the implementation takes into account biological information--such as base quality values--to improve performances without any significant loss in sensitivity.</p><p>Experimental results on the Vitis vinifera and Human genomes show that the dB-hash requires from 4 to 8 times less space than the standard hash used by ERNE (see Section). Tests run on both simulated and real reads show, in addition, that BW-ERNE maintains the same sensitivity of ERNE, improving also its throughput if reliable base qualities are available.</p></sec><sec sec-type="methods"><title>Methods</title><p>We begin to illustrate our general strategy, showing how to represent a hash index in succinct space by building a <italic>compact </italic>(<inline-formula><mml:math id="M9" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>(<italic>n </italic>log <italic>&#x003c3;</italic>) bits) representation of all the fingerprints of length-<italic>m </italic>text substrings. A succinct index is then built over this representation, obtaining a succinct hash data structure.</p><sec><title>Definitions</title><p>Throughout this paper we will work with the alphabet &#x003a3;<italic><sub>DN A </sub></italic>= {<italic>A, C, G, T, N</italic>, $} (with <italic>N </italic>and $ being the undefined base and the contig end-marker, respectively) which, in practice, will be encoded in &#x003a3;<italic><sub>DN A' </sub></italic>= {0, 1, 2, 3} assigning a numerical value in &#x003a3;<italic><sub>DN A' </sub></italic>to <italic>N </italic>and $ characters. The size of our alphabet is, therefore, <italic>&#x003c3; </italic>= |&#x003a3;<italic><sub>DN A'</sub></italic>| = 4, while with <italic>n</italic>, <italic>m</italic>, and <italic>w </italic>we will denote the reference length, the pattern length, and the (fixed) size of a computer memory-word (i.e. the number <italic>&#x003c3;<sup>w </sup></italic>&#x02212; 1 is assumed to fit in a memory word), respectively. As hash functions we will use functions of the form <italic>h </italic>: &#x003a3;<italic><sup>m </sup></italic>&#x02192; &#x003a3;<italic><sup>w </sup></italic>mapping length-<italic>m </italic>&#x003a3;-strings to length-<italic>w </italic>&#x003a3;-strings. If necessary, we will use the symbol <inline-formula><mml:math id="M10" name="1471-2105-16-S9-S4-i1" overflow="scroll"><mml:msubsup><mml:mrow><mml:mtext>&#x000a0;</mml:mtext></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mi>h</mml:mi></mml:math></inline-formula> instead of <italic>h </italic>when we need to be clear on <italic>h</italic>'s domain and codomain sizes. Given a string <inline-formula><mml:math id="M11" name="1471-2105-16-S9-S4-i2" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mover class="msup"><mml:mrow><mml:mo>&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mover></mml:mrow></mml:math></inline-formula>, the value <inline-formula><mml:math id="M12" name="1471-2105-16-S9-S4-i3" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mover class="msup"><mml:mrow><mml:mo>&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mover></mml:mrow></mml:math></inline-formula> will be also dubbed the <italic>fingerprint </italic>of P (in &#x003a3;<italic><sup>w</sup></italic>). With <inline-formula><mml:math id="M13" name="1471-2105-16-S9-S4-i4" overflow="scroll"><mml:mi>T</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mo class="MathClass-op">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> we will denote the <italic>text </italic>that we want to index using our data structure. <inline-formula><mml:math id="M14" name="1471-2105-16-S9-S4-i5" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> will denote <inline-formula><mml:math id="M15" name="1471-2105-16-S9-S4-i6" overflow="scroll"><mml:mi>T</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>i</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>j</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow></mml:math></inline-formula>, i.e. the length-<italic>j </italic>prefix of the <italic>i</italic>-th suffix of <italic>T</italic>. A hash data structure <italic>H </italic>for the text <italic>T </italic>with hash function <italic>h</italic>, will be a set of ordered pairs (an index) such that <inline-formula><mml:math id="M16" name="1471-2105-16-S9-S4-i7" overflow="scroll"><mml:mrow><mml:mi>H</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mfenced close="&#x027e9;" open="&#x027e8;"><mml:mrow><mml:mi>h</mml:mi><mml:mfenced close=")" open="("><mml:mrow><mml:msubsup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mfenced><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo class="MathClass-rel">:</mml:mo><mml:mn>0</mml:mn><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:mi>i</mml:mi><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:mi>n</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>m</mml:mi></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, that can be used to store and retrieve the positions of length-<italic>m </italic>substrings of <italic>T </italic>(<italic>m </italic>is therefore fixed once the index is built). A <italic>lookup </italic>operation on the hash <italic>H </italic>given the fingerprint <italic>h</italic>(<italic>P</italic>), will consist in the retrieval of all the positions <inline-formula><mml:math id="M17" name="1471-2105-16-S9-S4-i8" overflow="scroll"><mml:mn>0</mml:mn><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:mi>i</mml:mi><mml:mo class="MathClass-rel">&#x0003c;</mml:mo><mml:mi>n</mml:mi></mml:math></inline-formula> such that <inline-formula><mml:math id="M18" name="1471-2105-16-S9-S4-i9" overflow="scroll"><mml:mfenced close="&#x027e9;" open="&#x027e8;"><mml:mrow><mml:mi>h</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mi>H</mml:mi></mml:math></inline-formula> and cases where <inline-formula><mml:math id="M19" name="1471-2105-16-S9-S4-i10" overflow="scroll"><mml:mfenced close="&#x027e9;" open="&#x027e8;"><mml:mrow><mml:mi>h</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mfenced><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mi>H</mml:mi></mml:math></inline-formula> but <inline-formula><mml:math id="M20" name="1471-2105-16-S9-S4-i11" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mo class="MathClass-rel">&#x02260;</mml:mo><mml:mi>P</mml:mi></mml:math></inline-formula> will be referred to as <italic>false positives</italic>.</p><p>The symbol &#x02295; represents the exclusive OR (XOR) bitwise operator. <italic>a </italic>&#x02295; <italic>b </italic>where <inline-formula><mml:math id="M21" name="1471-2105-16-S9-S4-i12" overflow="scroll"><mml:mi>a</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>b</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mo class="MathClass-op">&#x02211;</mml:mo></mml:math></inline-formula>, will indicate the bitwise XOR among the bits of the binary encoding of <italic>a </italic>and <italic>b</italic>. Analogously, <italic>x </italic>&#x02295; <italic>y</italic>, where <inline-formula><mml:math id="M22" name="1471-2105-16-S9-S4-i13" overflow="scroll"><mml:mi>x</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>y</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mo class="MathClass-op">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> will indicate the bitwise XOR operation among the bits of the binary encoding of the two words <italic>x </italic>and <italic>y </italic>and V will denote the bitwise OR operator. <inline-formula><mml:math id="M23" name="1471-2105-16-S9-S4-i14" overflow="scroll"><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>y</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula> is the Hamming distance between <inline-formula><mml:math id="M24" name="1471-2105-16-S9-S4-i15" overflow="scroll"><mml:mi>x</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>y</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mo class="MathClass-op">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula>. We point out that the Hamming distance is computed between characters in &#x003a3;, and not between the bits of the binary encoding of each of them. Patterns and fingerprints are viewed as bit vectors only when computing bitwise operations such as OR, AND, and XOR.</p></sec><sec><title>Succinct representation of hash indexes</title><p>We begin by introducing the technique allowing succinct representation of hash indexes. The central property of the class of hash functions we are going to use is given by the following definition:</p><p><bold>Definition 1 </bold><italic>Let </italic>&#x003a3; = {0,..., |&#x003a3;| &#x02212;1}. <italic>We say that a function h </italic>: &#x003a3;<italic><sup>m </sup></italic>&#x02192; &#x003a3;<italic><sup>w </sup>is a </italic>de Bruijn <italic>hash function if and only if, for every pair of strings P, Q </italic>&#x02208; &#x003a3;<italic><sup>m</sup></italic></p><p><disp-formula><mml:math id="M25" name="1471-2105-16-S9-S4-i16" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo class="MathClass-rel">=</mml:mo><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo class="MathClass-rel">&#x021d2;</mml:mo><mml:mi>h</mml:mi><mml:msubsup><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo class="MathClass-rel">=</mml:mo><mml:mi>h</mml:mi><mml:msubsup><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></disp-formula></p><p>With the following theorem we introduce the hash function used in the rest of our work and in the implementation of our structure:</p><p><bold>Theorem 1 </bold><italic>Let P </italic>&#x02208; &#x003a3;<italic><sup>m</sup></italic>. <italic>The hash function h</italic><sub>&#x02295; </sub>: &#x003a3;<italic><sup>m </sup></italic>&#x02192; &#x003a3;<italic><sup>w </sup>w </italic>&#x02264; <italic>m </italic><italic>defined as</italic></p><p><disp-formula><mml:math id="M26" name="1471-2105-16-S9-S4-i17" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mo class="MathClass-bin">&#x02295;</mml:mo><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo class="MathClass-op">&#x02295;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mfenced close="&#x02309;" open="&#x02308;"><mml:mrow><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">/</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfenced><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:munderover></mml:mstyle><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mspace class="tmspace" width="2.77695pt"/><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mfenced><mml:mo class="MathClass-bin">&#x02295;</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></disp-formula></p><p><italic>is a de Bruijn hash function</italic>.</p><p>A detailed proof of this theorem is given in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>. Given a de Bruijn hash function <inline-formula><mml:math id="M27" name="1471-2105-16-S9-S4-i18" overflow="scroll"><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mi>h</mml:mi><mml:mo class="MathClass-rel">:</mml:mo><mml:msup><mml:mrow><mml:mo class="MathClass-op">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup><mml:mo class="MathClass-rel">&#x02192;</mml:mo><mml:msup><mml:mrow><mml:mo class="MathClass-op">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> we can "extend" it to another de Bruijn hash function <inline-formula><mml:math id="M28" name="1471-2105-16-S9-S4-i19" overflow="scroll"><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>n</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mi>h</mml:mi><mml:mo class="MathClass-rel">:</mml:mo><mml:mover class="msup"><mml:mrow><mml:mo> &#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mover><mml:mo class="MathClass-rel">&#x02192;</mml:mo><mml:mover class="msup"><mml:mrow><mml:mo>&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mover></mml:math></inline-formula>, operating on input strings of length <italic>n </italic>greater than or equal to <italic>m</italic>, as follows:</p><p><bold>Definition 2 </bold><italic>Given <inline-formula><mml:math id="M29" name="1471-2105-16-S9-S4-i20" overflow="scroll"><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mi>h</mml:mi><mml:mo class="MathClass-rel">:</mml:mo><mml:msup><mml:mrow><mml:mo class="MathClass-op">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup><mml:mo class="MathClass-rel">&#x02192;</mml:mo><mml:msup><mml:mrow><mml:mo class="MathClass-op">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> de Bruijn hash function and n </italic>&#x02265; <italic>m, the hash value of <inline-formula><mml:math id="M30" name="1471-2105-16-S9-S4-i21" overflow="scroll"><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>n</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mi>h</mml:mi></mml:math></inline-formula> on T </italic>&#x02208; &#x003a3;<italic><sup>n</sup>, is the unique string <inline-formula><mml:math id="M31" name="1471-2105-16-S9-S4-i22" overflow="scroll"><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>n</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mi>h</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mover class="msup"><mml:mrow><mml:mo>&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mover></mml:math></inline-formula> such that:</italic></p><p><disp-formula><mml:math id="M32" name="1471-2105-16-S9-S4-i23" overflow="scroll"><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>n</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mi>h</mml:mi><mml:msubsup><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msubsup><mml:msubsup><mml:mrow><mml:mo class="MathClass-rel">=</mml:mo></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mi>h</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo></mml:math></disp-formula></p><p><italic>for every </italic>0 &#x02264; <italic>i </italic>&#x02264; <italic>n </italic>&#x02212; <italic>m</italic>.</p><p>It is easy to show that a function enjoying the property in Definition 2 is a homomorphism on de Bruijn graphs (having as sets of nodes &#x003a3;<italic><sup>m </sup></italic>and &#x003a3;<italic><sup>w</sup></italic>, respectively). Since <inline-formula><mml:math id="M33" name="1471-2105-16-S9-S4-i24" overflow="scroll"><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup><mml:mi>h</mml:mi></mml:math></inline-formula> univocally determines <inline-formula><mml:math id="M34" name="1471-2105-16-S9-S4-i25" overflow="scroll"><mml:msubsup><mml:mrow/><mml:mrow><mml:mi>n</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup><mml:mi>h</mml:mi></mml:math></inline-formula> and the two functions coincide on the common part &#x003a3;<italic><sup>m </sup></italic>of their domain, in what follows we will simply use the symbol <italic>h </italic>to indicate both.</p><p>From Definitions 1 and 2 we can immediately derive the following important property:</p><p><bold>Lemma 1 </bold><italic>If h is a de Bruijn hash function, n </italic>&#x02265; <italic>m, and P </italic>&#x02208; &#x003a3;<italic><sup>m </sup>occurs in T </italic>&#x02208; &#x003a3;<italic><sup>n </sup>at position i, then h</italic>(<italic>P</italic>) <italic>occurs in h</italic>(<italic>T</italic>) <italic>at position i. The opposite implication does not (always) hold; we will refer to cases of the latter kind as false positives</italic>.</p><p>On the ground of Lemma 1 we can propose, differently from standard approaches in the literature, to build an index <italic>over the hash value of the text</italic>, instead of building it over the text. This can be done while preserving our ability to locate substrings in the text, since we can simply turn our task into that of locating <italic>fingerprints </italic>in the hash of the text <italic>T</italic>. We call dB-hash the data structure obtained with this technique. Notice that the underlying hash data structure is simulated by searching the occurrences of <italic>h</italic>(<italic>P</italic>) in <italic>h</italic>(<italic>T</italic>) during a lookup operation, so the algorithm is transparent to the particular indexing technique used.</p></sec><sec><title>Search algorithm</title><p>The core of our searching procedure is based on the algorithm <italic>rNA </italic>(Vezzi et al. [<xref ref-type="bibr" rid="B5">5</xref>], Policriti et al. [<xref ref-type="bibr" rid="B6">6</xref>]), a hash-based randomized numerical aligner based on the concept of <italic>Hamming-aware </italic>hash functions (see [<xref ref-type="bibr" rid="B5">5</xref>] and [<xref ref-type="bibr" rid="B6">6</xref>] for more details). Hamming-aware hash functions are particular hash functions capable to "squeeze" the Hamming ball of radius <italic>k </italic>around a pattern P to a Hamming ball of the same radius around the hash value of <italic>P</italic>. This feature allows to search the entire Hamming ball around <italic>P </italic>much more efficiently. The following theorem holds:</p><p><bold>Theorem 2 </bold><italic>The de Bruijn function </italic><italic>h</italic><sub>&#x02295; </sub><italic>defined in Definition 1 is a Hamming aware hash function. In particular:</italic></p><p><disp-formula><mml:math id="M35" name="1471-2105-16-S9-S4-i26" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>P</mml:mi><mml:mi>&#x02032;</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:mi>k</mml:mi><mml:mo class="MathClass-rel">&#x021d2;</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">&#x02295;</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">&#x02295;</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mi>&#x02032;</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></disp-formula></p><p>for every <inline-formula><mml:math id="M36" name="1471-2105-16-S9-S4-i27" overflow="scroll"><mml:mi>P</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>P</mml:mi><mml:mi>&#x02032;</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:msubsup><mml:mrow><mml:mo class="MathClass-op">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>N</mml:mi><mml:mspace class="tmspace" width="2.77695pt"/><mml:mi>A</mml:mi><mml:mi>&#x02032;</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula></p><p>See Additional file <xref ref-type="supplementary-material" rid="S1">1</xref> for a detailed proof of this theorem. Since <italic>h</italic><sub>&#x02295; </sub>is a de Bruijn <italic>and </italic>Hamming aware hash function, we can use it to build our structure and adapt the rNA algorithm to it. We call dB-rNA the new version of the rNA algorithm adapted to the dB hash data structure. More in detail, the Hamming-awareness property of <italic>h</italic><sub>&#x02295; </sub>guarantees that, given a pattern <italic>P </italic>to be searched in the index, the set {<italic>h</italic><sub>&#x02295;</sub>(<italic>P'</italic>) : <italic>d<sub>H</sub></italic>(<italic>P, P'</italic>) &#x02264; <italic>k</italic>} is small--<inline-formula><mml:math id="M37" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>((2<italic>&#x003c3; </italic>&#x02212; 2)<italic><sup>k </sup>w<sup>k</sup></italic>) = <inline-formula><mml:math id="M38" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>(6<italic><sup>k </sup>w<sup>k</sup></italic>) elements in our application--and can be computed in time proportional to its size. Notice that, with a generic hash function <italic>h</italic>, only the trivial upper bound <inline-formula><mml:math id="M39" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>((<italic>&#x003c3; </italic>&#x02212; 1)<italic><sup>k </sup>m<sup>k</sup></italic>) can be given to the size of this set since each different <italic>P'</italic> such that <italic>d<sub>H</sub></italic>(<italic>P, P'</italic>) &#x02264; <italic>k </italic>could give rise to a distinct fingerprint. Our proposed algorithm is almost the same as the one described in [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B6">6</xref>], the only difference being that the underlying data structure is a dB-hash instead of a standard hash. Briefly, the search proceeds in 3 steps. For each pattern <italic>P</italic>:</p><p>1 <italic>h</italic><sub>&#x02295;</sub>(<italic>P</italic>) is computed;</p><p>2 the index is searched for each element in the set <inline-formula><mml:math id="M40" name="1471-2105-16-S9-S4-i28" overflow="scroll"><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mi>h</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mi>&#x02032;</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>P</mml:mi><mml:mi>&#x02032;</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:math></inline-formula>,</p><p>3 for each occurrence found, the text and the pattern <italic>P </italic>are compared to determine Hamming distance and discard false positives.</p><p>In practice, in our implementation we also split the pattern <italic>P </italic>in non-overlapping blocks before searching the index. With this strategy we reduce the maximum number of errors to be searched, improving the speed of the tool.</p></sec><sec><title>Complexity analysis</title><p>Let <italic>occ </italic>be the number of occurrences with at most <italic>k </italic>errors of the searched pattern <italic>P </italic>in <italic>T</italic>. Assuming that the alphabet size <italic>&#x003c3; </italic>is a power of 2 (condition satisfied in our application), the expected complexity on uniformly distributed inputs of our algorithm has an upper bound of</p><p><disp-formula><mml:math id="M41" name="1471-2105-16-S9-S4-i29" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mtext class="textsf" mathvariant="sans-serif">log</mml:mtext><mml:mi>n</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mtext class="textsf" mathvariant="sans-serif">log</mml:mtext><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>o</mml:mi><mml:mi>c</mml:mi><mml:mi>c</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-bin">&#x022c5;</mml:mo><mml:mi>m</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo></mml:mrow></mml:math></disp-formula></p><p>here, <italic>&#x003c3; </italic>= 4 is the size of the alphabet &#x003a3;<italic><sub>DN A'</sub></italic>. A fully formal proof of (an extended version of) this analysis can be found in [<xref ref-type="bibr" rid="B11">11</xref>].</p></sec><sec><title>Quality-aware strategy</title><p>Our tool implements a quality-aware heuristic that significantly improves search speed, at the price of a small loss in sensitivity. Briefly, we use base qualities to pick up only a small fraction of the elements from the Hamming ball centred on the hash <italic>h</italic>(<italic>B</italic>) of the searched block <italic>B</italic>, following the assumption that a high quality base is unlikely to be a miscall. Since in practice we divide the read in non-overlapping blocks and the heuristic affects only the searched block, with this strategy we lose only a small fraction of single variants like SNPs. More in detail, let <inline-formula><mml:math id="M42" name="1471-2105-16-S9-S4-i30" overflow="scroll"><mml:mrow><mml:mi>Q</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mi>&#x02115;</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> be (e.g.) the Phred quality (see [<xref ref-type="bibr" rid="B12">12</xref>]) string associated to the searched block <italic>B</italic>. We compute a hash value on <italic>Q </italic>using the following hash function:</p><p><bold>Definition 3 </bold>With <inline-formula><mml:math id="M43" name="1471-2105-16-S9-S4-i31" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">&#x02228;</mml:mo></mml:mrow></mml:msub><mml:mo class="MathClass-rel">:</mml:mo><mml:msup><mml:mrow><mml:mi>&#x02115;</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msup><mml:mo class="MathClass-rel">&#x02192;</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo class="MathClass-punc">,</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> we indicate the hash function defined as</p><p><disp-formula><mml:math id="M44" name="1471-2105-16-S9-S4-i32" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">&#x02228;</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:msubsup><mml:mrow><mml:mo class="MathClass-bin">&#x02228;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mfenced close="&#x02309;" open="&#x02308;"><mml:mrow><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">/</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:mfenced><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:mfenced><mml:mo class="MathClass-bin">&#x02228;</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>where <inline-formula><mml:math id="M45" name="1471-2105-16-S9-S4-i33" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">:</mml:mo><mml:msup><mml:mrow><mml:mi>&#x02115;</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup><mml:mo class="MathClass-rel">&#x02192;</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo class="MathClass-punc">,</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> is defined as</p><p><disp-formula><mml:math id="M46" name="1471-2105-16-S9-S4-i34" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mfenced open="{"><mml:mrow><mml:mtable class="array" columnlines="none" equalcolumns="false" equalrows="false"><mml:mtr><mml:mtd class="array" columnalign="center"><mml:mn>0</mml:mn><mml:mspace class="quad" width="1em"/><mml:mi>i</mml:mi><mml:mi>f</mml:mi><mml:mspace class="tmspace" width="2.77695pt"/><mml:mi>Q</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x0003e;</mml:mo><mml:mi>q</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd class="array" columnalign="center"><mml:mn>3</mml:mn><mml:mspace class="quad" width="1em"/><mml:mtext class="textsf" mathvariant="sans-serif">otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable><mml:mspace class="quad" width="1em"/><mml:mo class="MathClass-punc">,</mml:mo><mml:mspace class="tmspace" width="2.77695pt"/><mml:mi>i</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:mn>0</mml:mn><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>w</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></disp-formula></p><p><italic>q </italic>is a quality threshold (in our implementation we use <italic>q </italic>= 15). The values 0 and 3 have been chosen due to their binary representation (00 and 11, respectively). If <inline-formula><mml:math id="M47" name="1471-2105-16-S9-S4-i35" overflow="scroll"><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">&#x02228;</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mn>3</mml:mn></mml:math></inline-formula>, then during search we try to insert an error in position <italic>i </italic>of <italic>h</italic><sub>&#x02295; </sub>(<italic>B</italic>) since at least one of the bases used to compute <italic>h</italic><sub>&#x02295; </sub>(<italic>B</italic>)[<italic>i</italic>] has a low-quality. The quality-aware strategy is then implemented as follows: let <italic>B </italic>be the block to be searched and <italic>Q </italic>its associated Phred quality string. A fingerprint <italic>f </italic>(representing a block at distance at most <italic>k </italic>from <italic>B</italic>) is searched in the structure if and only if <inline-formula><mml:math id="M48" name="1471-2105-16-S9-S4-i36" overflow="scroll"><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>f</mml:mi><mml:mo class="MathClass-bin">&#x02295;</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">&#x02295;</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-bin">&#x02228;</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">&#x02228;</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">&#x02228;</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula>, i.e. if <italic>f </italic>differs from <italic>h</italic><sub>&#x02295;</sub>(<italic>B</italic>) only in positions corresponding to low quality bases. Since the number of low-quality base pairs in a read is typically low, this strategy allows to drastically reduce search space (which in practice leads approximately to a 10x speedup) if reliable qualities are available. In the results section we show, moreover, that this strategy has only a negligible impact on SNP detection and on the overall precision of our tool.</p></sec><sec><title>BW-ERNE: implementation details</title><p>We implemented our algorithm and data structure in the short reads aligner BW-ERNE (<italic>Burrows-Wheeler Extended Randomized Numerical alignEr</italic>), downloadable at <ext-link ext-link-type="uri" xlink:href="http://erne.sourceforge.net">http://erne.sourceforge.net</ext-link>. As hash function for our index we use <italic>h</italic><sub>&#x02295;</sub>. Given a text <inline-formula><mml:math id="M49" name="1471-2105-16-S9-S4-i37" overflow="scroll"><mml:mi>T</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:msubsup><mml:mrow><mml:mo class="MathClass-op">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>N</mml:mi><mml:mspace class="tmspace" width="2.77695pt"/><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula>, we calculate <italic>h</italic><sub>&#x02295; </sub>(<italic>T</italic>)<italic><sup>BW T</sup></italic>--the Burrows-Wheeler transform of <italic>h</italic><sub>&#x02295;</sub>(<italic>T</italic>)--adding the necessary additional structures needed to perform backward search and to retrieve text positions from <italic>h</italic><sub>&#x02295; </sub>(T)<italic><sup>BW T </sup></italic>positions. BW-ERNE includes (from its predecessor ERNE) also a simple and fast strategy to allow a single indel in the alignment. This strategy does not affect running times and permits to correctly align a large fraction of short reads that come with indels (see Results section). It is well known that DNA is extremely difficult to compress and for this reason we choose not to introduce compression in our structure. Even if our index is not compressed, experiments show (see Section) that its memory requirements are similar or even smaller than those of other tools based on the FM index such as Bowtie [<xref ref-type="bibr" rid="B2">2</xref>], BWA [<xref ref-type="bibr" rid="B4">4</xref>] and SOAP2 [<xref ref-type="bibr" rid="B3">3</xref>]. Briefly, the structure is composed by three parts: the index, the plain text, and an auxiliary (standard) hash.</p><sec><title>BWT index</title><p>The BWT index is constituted by <inline-formula><mml:math id="M50" name="1471-2105-16-S9-S4-i38" overflow="scroll"><mml:mrow><mml:msub><mml:mi>h</mml:mi><mml:mo class="MathClass-bin">&#x02295;</mml:mo></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>B</mml:mi><mml:mi>W</mml:mi><mml:mi>T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> stored as a wavelet tree (<italic>n </italic>log <italic>&#x003c3; </italic>bits), <italic>rank </italic>counters (<italic>o</italic>(<italic>n </italic>log <italic>&#x003c3;</italic>) bits), and sampled suffix array pointers for its navigation (<italic>n </italic>+ <italic>o</italic>(<italic>n</italic>)) bits for one rank structure and 2<italic>n </italic>bits for one SA pointer every 16 text positions; the user can however modify the SA pointers density).</p></sec><sec><title>Plain text</title><p><inline-formula><mml:math id="M51" name="1471-2105-16-S9-S4-i39" overflow="scroll"><mml:mi>T</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:msubsup><mml:mrow><mml:mo class="MathClass-op">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mi>N</mml:mi><mml:mspace class="tmspace" width="2.77695pt"/><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> is stored in a 3-bits per base format in blocks of 8 symbols (3<italic>n </italic>bits). We exploit this encoding to perform <inline-formula><mml:math id="M52" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>(1) text-query comparison of a single block, improving the speed of the algorithm.</p></sec><sec><title>Auxiliary hash</title><p>To speed up lookup operations, we finally store an auxiliary hash <italic>H<sup>AU X </sup></italic>that indexes the <italic>w<sub>aux </sub></italic>most significant digits of the fingerprints: the intervals obtained by backward search on all the numbers in the set <inline-formula><mml:math id="M53" name="1471-2105-16-S9-S4-i40" overflow="scroll"><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:msup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>u</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:math></inline-formula> are precomputed and stored in <italic>H<sup>AU X</sup></italic>. In this way, a lookup operation on <italic>H<sup>BW T </sup></italic>requires one lookup in <italic>H<sup>AU X </sup></italic>followed by <italic>w </italic>&#x02212; <italic>w<sub>aux </sub></italic>steps of backward search. We require <italic>H<sup>AU X </sup></italic>to occupy only <italic>n </italic>bits. This limit gives us an upper bound for <italic>w<sub>aux </sub></italic>of <inline-formula><mml:math id="M54" name="1471-2105-16-S9-S4-i41" overflow="scroll"><mml:msub><mml:mrow><mml:mtext class="textsf" mathvariant="sans-serif">log</mml:mtext></mml:mrow><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow></mml:msub><mml:mi>n</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:msub><mml:mrow><mml:mtext class="textsf" mathvariant="sans-serif">log</mml:mtext></mml:mrow><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mtext class="textsf" mathvariant="sans-serif">log</mml:mtext></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math></inline-formula>. It can be proved [<xref ref-type="bibr" rid="B11">11</xref>] that the optimal word size for our algorithm is <inline-formula><mml:math id="M55" name="1471-2105-16-S9-S4-i42" overflow="scroll"><mml:mi>w</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:msub><mml:mrow><mml:mtext class="textsf" mathvariant="sans-serif">log</mml:mtext></mml:mrow><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula>. Combining these results it follows that the cost of a lookup operation in our data structure is <inline-formula><mml:math id="M56" name="1471-2105-16-S9-S4-i44" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">&#x000a0;O</mml:mi></mml:mrow></mml:math></inline-formula>(log <italic>m</italic>).</p><p>Summing up, the total space occupancy of the dB-hash data structure implemented in BW-ERNE is of <inline-formula><mml:math id="M57" name="1471-2105-16-S9-S4-i43" overflow="scroll"><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mspace class="tmspace" width="2.77695pt"/><mml:mtext class="textsf" mathvariant="sans-serif">log</mml:mtext><mml:mi>&#x003c3;</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mn>4</mml:mn><mml:mi>n</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>o</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mspace class="tmspace" width="2.77695pt"/><mml:mtext class="textsf" mathvariant="sans-serif">log</mml:mtext><mml:mspace class="tmspace" width="2.77695pt"/><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula> bits, corresponding in practice to approximately 1.4<italic>n </italic>Bytes (this fraction may slightly vary for different reference sizes): the index is succinct.</p></sec></sec></sec><sec sec-type="results"><title>Results</title><p>In order to assess the performances of BW-ERNE, we performed extensive experiments on two genomes: <italic>Vitis vinifera </italic>(480 Mbp) and <italic>Human genome </italic>(hg19 reference, 3.2 Gbp).</p><p>Simulations on Vitis vinifera were used to compare the alignment accuracy and speed of BW-ERNE, its (old) standard-hash counterpart ERNE, Bowtie, BWA, and SOAP2, in presence of reliable base qualities on a medium-sized genome. Hence, in order to precisely asses the correctness of our results, we used simulated data produced by the SimSeq simulator, <ext-link ext-link-type="uri" xlink:href="https://github.com/jstjohn/SimSeq">https://github.com/jstjohn/SimSeq</ext-link>. Experiments on real data (not reported here as subsumed by the experiments on human) confirm the conclusions.</p><p>Experiments on the Human genome, instead, were performed in order to assess the precision of BW-ERNE in absence of base quality information (we per-formed a GCAT test, <ext-link ext-link-type="uri" xlink:href="http://www.bioplanet.com/gcat">http://www.bioplanet.com/gcat</ext-link>/), to assess the impact of BW-ERNE's quality-aware strategy on SNPs detection (using SimSeq and random SNP simulation), and to assess the performances of our aligner on a real 10x coverage Illumina library downloaded from the 1000genomes project's database (<ext-link ext-link-type="uri" xlink:href="http://www.1000genomes.org">http://www.1000genomes.org</ext-link>/).</p><p>All experiments were performed on a intel core i7 machine with 12 GB of RAM running Ubuntu 14.04 operating system. See Additional file <xref ref-type="supplementary-material" rid="S2">2</xref> and Additional file <xref ref-type="supplementary-material" rid="S3">3</xref> for further informations about the implementation usage and the commands used to perform the experiments, respectively.</p><sec><title>Memory footprint of the indexes</title><p>BW-ERNE significantly reduces the space requirements of ERNE, requiring approximately 8.7 times less space on the Vitis Vinifera genome (730 MB vs 64 GB) and approximately 4.4 times less space on the Human genome (4.3 GB vs 19 GB). The plot in Figure <xref ref-type="fig" rid="F1">1</xref> compares the different indexes sizes on Vitis Vinifera and gives a clear idea of the most important difference between full-text and succinct indexes, the former requiring space proportional to <italic>n </italic>log <italic>n </italic>(<italic>n </italic>pointers to the text) while the latter is using an amount of space close to that necessary for the plain text. More-over, differences among BWT-based tools are minimal (few hundred MB) if compared to the gap between hash-based (ERNE) and BWT-based (Bowtie, BWA, SOAP2, BW-ERNE) aligners. Among the tested tools only Bowtie requires less space than our tool, even if in the dB-hash data structure we do not perform any data compression. This is due to the fact that DNA is a high-entropy string and, therefore, almost incompressible using standard techniques such as the ones implemented in the FM index. Finally, the horizontal green line, marking the size of the reference fasta file, gives an idea of how efficiently can succinct and compressed indexes represent their structures: in particular, Bowtie is able to reach a RAM memory footprint that is <italic>smaller </italic>than that of the reference file itself, while BWA and BW-ERNE require slightly more space. On the Human genome, BW-ERNE index requires only 4.3 GB of space to be stored and loaded during alignment. This is slightly more than the indexes of Bowtie and BWA (2.7 GB and 3.2 GB of RAM, respectively), but considerably less than ERNE's hash table, which requires 19 GB of space to be stored and loaded during alignment.</p><fig id="F1" position="float"><label>Figure 1</label><caption><p><bold>Space required by the tested tools (Vitis Vinifera genome) This plot compares the space needed by some of the most popular short-read aligners to index the Vitis Vinifera genome</bold>. We reported space on disk (storage of the index) and RAM (structures loaded in memory). Full text indexes such as the hash data structure implemented in ERNE require much more space than the succinct and compressed indexed used by the other tools. Notice that the space required by succinct (BW-ERNE) and compressed (Bowtie, SOAP2, BWA) indexes is almost the same in DNA indexing: this is due to the fact that DNA is, in general, extremely difficult to compress.</p></caption><graphic xlink:href="1471-2105-16-S9-S4-1"/></fig></sec><sec><title>Simulated data with reliable base qualities</title><p>In this experiment we compared the tools on 5M of 100bp single-end reads with simulated base qualities. This dataset was generated from the Vitis Vinifera genome using the SimSeq simulator, adopting the built-in Illumina error model. The number of correctly mapped reads was estimated comparing the bam files generated by SimSeq and the aligners (reads mapping in multiple locations were evaluated on the unique reported alignment).</p><p>The plots in Figure <xref ref-type="fig" rid="F2">2</xref> show that BW-ERNE is able to exploit at best quality information without losing accuracy with respect to ERNE while, at the same time, improving significantly its performances. BWERNE was executed with default settings and using 1 thread. The plot on the left hand side of Figure <xref ref-type="fig" rid="F2">2</xref> shows that BW-ERNE was 2 times faster than Bowtie, and 4 times faster than BWA. This speed came with no penalties on the number of mapped reads, which was the highest among all tools, with BW-ERNE and ERNE aligning 97% of all reads, BWA 94%, Bowtie 90% and SOAP2 82%. Finally, the plot on the right hand side of Figure <xref ref-type="fig" rid="F2">2</xref> shows the accuracy of the tools in terms of correctly mapped reads. The gap between mapped and correctly mapped reads is due to reads mapping in multiple locations, which were judged on the base of the unique reported alignment. The plot shows that ERNE and BW-ERNE were the most accurate tools, correctly aligning the highest number of reads.</p><fig id="F2" position="float"><label>Figure 2</label><caption><p><bold>Results on 5M 100 bp single-end reads simulated using the tool SimSeq (Vitis Vinifera genome) These experiments allowed us to judge how the presence of reliable base qualities affected the quality-aware strategies of Bowtie and BW-ERNE</bold>. The left plot shows that BW-ERNE is able to exploit at best the presence of reliable base qualities: our tool was several times faster than the other tools, while at the same time correctly aligning the highest number of reads (together with ERNE).</p></caption><graphic xlink:href="1471-2105-16-S9-S4-2"/></fig></sec><sec><title>Simulated data without reliable base qualitie</title><p>A public GCAT experiment (Human genome) was performed in order to assess the precision of our tool in absence of reliable base qualities. The experiment consisted of 12M 100bp single-end reads with 0.02% small indel frequency. The results are available at the address <ext-link ext-link-type="uri" xlink:href="http://www.bioplanet.com/gcat/reports/3705-muwwfqmbjb/alignment/100bp-se-small-indel/BW-ERNE/compare-26-27-38">http://www.bioplanet.com/gcat/reports/3705-muwwfqmbjb/alignment/100bp-se-small-indel/BW-ERNE/compare-26-27-38</ext-link>. In this experiment, BWERNE was executed with the option --sensitive, which ignores base qualities (not meaningful in the GCAT simulation), and using 4 threads. BW-ERNE completed the alignment in 1 hour and 28 minutes, for an overall throughput of 8M reads per hour (approximately 4x faster than with only 1 thread). The results are reported in Table <xref ref-type="table" rid="T1">1</xref>: BW-ERNE was one of the most accurate aligners, correctly aligning 97.3% of all the reads. This fraction is comparable to that of Novoalign and BWA-mem, and higher than that of Bowtie2 and BWA.</p><table-wrap id="T1" position="float"><label>Table 1</label><caption><p>Results of the GCAT experiment (data coming from GCAT website).</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center">Tool</th><th align="center">Total Reads</th><th align="center">Correct</th><th align="center">Incorrect</th><th align="center">Unmapped</th></tr></thead><tbody><tr><td align="center">BW-ERNE</td><td align="center">11,945,249</td><td align="center">97.30%</td><td align="center">2.311%</td><td align="center">0.3900%</td></tr><tr><td align="center">Bowtie2</td><td align="center">11,945,249</td><td align="center">93.52%</td><td align="center">5.284%</td><td align="center">1.192%</td></tr><tr><td align="center">Novoalign</td><td align="center">11,945,249</td><td align="center">97.47%</td><td align="center">0.08329%</td><td align="center">2.445%</td></tr><tr><td align="center">Novoalign3</td><td align="center">11,945,249</td><td align="center">97.47%</td><td align="center">0.08300%</td><td align="center">2.442%</td></tr><tr><td align="center">BWA</td><td align="center">11,945,249</td><td align="center">93.91%</td><td align="center">1.707%</td><td align="center">4.385%</td></tr><tr><td align="center">BWA-SW</td><td align="center">11,971,702</td><td align="center">94.29%</td><td align="center">4.139%</td><td align="center">1.576%</td></tr><tr><td align="center">BWA-MEM</td><td align="center">11,951,583</td><td align="center">97.47%</td><td align="center">2.515%</td><td align="center">0.01361%</td></tr></tbody></table><table-wrap-foot><p>BW-ERNE ranks among the most precise tools, correctly aligning a number of reads comparable to that of slower aligners such as Novoalign.</p></table-wrap-foot></table-wrap></sec><sec><title>Validation of the quality-aware strategy in presence of SNPs</title><p>In order to assess the impact of our quality-aware strategy on SNP detection, we simulated (using SimSeq) 10M of 100bp single-end reads, using as reference the Human genome (hg19). After the simulation, each base was randomly substituted with probability 0.005 to simulate SNPs (which, from the aligner's point of view, are simply mismatches with high base-quality). This strategy allowed us to track reads containing SNPs, permitting a separate verification of the alignment's correctness for reads with and without this kind of mutations. BW-ERNE was executed twice on the mutated dataset: with default settings (quality-aware strategy enabled) and with the --sensitive option enabled (quality-aware strategy disabled). An alignment was considered correct if and only if both chromosome and strand coincided with those outputted by SimSeq and if the alignment's position was within 50 bases from the position outputted by Simseq (in order to account for indels and clipped bases). Reads with multiple alignments were judged on the basis of their unique reported alignment. Of the 10M simulated reads, 39.42% contained at least one SNP. BWERNE in sensitive mode (quality-aware strategy disabled) correctly aligned 87.80% of the reads <italic>without </italic>SNPs and 87.64% of the reads <italic>with </italic>SNPs, thus showing (as expected) no significant bias towards reads without SNPs (the 0.16% difference can be explained with the fact that reads with SNPs are inherently more difficult to align). BW-ERNE with the quality-aware strategy enabled correctly aligned 86.54% of the reads <italic>without </italic>SNPs and 85.25% of the reads <italic>with </italic>SNPs, thus showing only a slight bias towards reads without SNPs.</p></sec><sec><title>Real data -- Human genome</title><p>To conclude, the experiment on a real high-coverage Human Illumina library, allowed us to validate the results obtained on simulated reads and to assess the performances of BW-ERNE on large datasets. In this experiment we aligned 320M of 100bp pairedend reads, corresponding to a 10x coverage of the Human genome, downloaded from the 1000genomes project's database (top 160M reads in ftp://ftp. <ext-link ext-link-type="uri" xlink:href="http://1000genomes.ebi.ac.uk/vol1/ftp/data/NA12878/sequence_read/SRR622457_1.filt.fastq.gz">http://1000genomes.ebi.ac.uk/vol1/ftp/data/NA12878/sequence_read/SRR622457_1.filt.fastq.gz</ext-link> and top 160M reads in <ext-link ext-link-type="ftp" xlink:href="ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data/NA12878/sequence_read/SRR622457_2.filt.fastq.gz">ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data/NA12878/sequence_read/SRR622457_2.filt.fastq.gz</ext-link>). BW-ERNE was executed with default settings (quality-aware strategy enabled) and using 4 threads. Our tool completed the alignment in 3 hours and 15 minutes, for an overall throughput of 98 millions of reads per hour. 15916364 reads (5% of all the reads) were automatically discarded by the builtin trimmer due to low base quality. Of the remaining 304083636 reads, 300717664 (98.9%) were successfully aligned to the reference and 3365972 (1.1%) were not found. Among the aligned reads, 284650317 (94.6%) were aligned in only one position and 16067347 (5.4%) in multiple positions.</p></sec></sec><sec sec-type="conclusions"><title>Conclusions</title><p>In this paper we presented a new technique that permits a succinct representation of hash indexes using hash functions with the property of being Hamming-aware and homomorphisms on de Bruijn graphs. We used this technique to build a succinct index--dubbed dB-hash--which, combined with a previously published hash-based algorithm, allowed us to lower the upper bound to the average-case complexity of the <italic>k</italic>-mismatch problem in succinct space. We implemented our algorithm and data structure in the short-reads aligner BW-ERNE. Tests on both simulated and real data, using the most popular short reads aligners, allowed us to validate also in practice the efficiency of our algorithm, which proved to be extremely accurate and fast, especially if reliable base qualities are available.</p><p>We are exploring numerous extensions of the work discussed here, on both the theoretical and practical side. From the theoretical point of view, we are studying ways to extend our complexity results to a more general analysis of hashing, which could turn out useful in the complexity analysis of hash-based algorithms. Other theoretical extensions of our work include the study of the properties of <italic>h</italic><sub>&#x02295; </sub>as a <italic>text transform</italic>, randomizing the text and to be used in combination with existing pattern-matching algorithms. From the practical point of view, we are extending our BW-ERNE aligner with several new features such as long-reads alignment (combining the techniques discussed here with gapped strategies) and bisulfite-treated reads alignment (see [<xref ref-type="bibr" rid="B13">13</xref>]).</p></sec><sec><title>Availability</title><p>ERNE (<italic>Extended Randomized Numerical alignEr</italic>, version 2) is a short string alignment package whose goal is to provide an all-inclusive set of tools to handle short reads. ERNE comprises: ERNE-MAP, ERNE-DMAP, ERNE-FILTER, ERNE-VISUAL, ERNE-BS5, and ERNE-METH. ERNE is free software and distributed with an Open Source License (GPL V3) and can be downloaded at: <ext-link ext-link-type="uri" xlink:href="http://erne.sourceforge.net">http://erne.sourceforge.net</ext-link></p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>Both authors equally contributed to the idea and to the design of the algorithm and the experiments. NP developed the tool and performed the experiments. Both authors wrote the paper.</p></sec><sec sec-type="supplementary-material"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="S1"><caption><title>Additional file 1</title><p>proofs of theorems file: additional file 1.pdf</p></caption><media xlink:href="1471-2105-16-S9-S4-S1.pdf"><caption><p>Click here for file</p></caption></media></supplementary-material><supplementary-material content-type="local-data" id="S2"><caption><title>Additional file 2</title><p>implementation usage file: additional file 2.pdf</p></caption><media xlink:href="1471-2105-16-S9-S4-S2.pdf"><caption><p>Click here for file</p></caption></media></supplementary-material><supplementary-material content-type="local-data" id="S3"><caption><title>Additional file 3</title><p>commands used to perform the experiments file: additional file 3.pdf</p></caption><media xlink:href="1471-2105-16-S9-S4-S3.pdf"><caption><p>Click here for file</p></caption></media></supplementary-material></sec></body><back><sec><title>Declarations</title><p>The publication costs for this article were supported by the Italian EPIGEN Flagship Project.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 16 Supplement 9, 2015: Proceedings of the Italian Society of Bioinformatics (BITS): Annual Meeting 2014: Bioinformatics. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/bmcbioinformatics/supplements/16/S9">http://www.biomedcentral.com/bmcbioinformatics/supplements/16/S9</ext-link>.</p></sec><ref-list><ref id="B1"><mixed-citation publication-type="other"><name><surname>Ferragina</surname><given-names>P</given-names></name><name><surname>Manzini</surname><given-names>G</given-names></name><article-title>Opportunistic data structures with applications</article-title><source>Foundations of Computer Science, 2000 Proceedings 41st Annual Symposium on</source><year>2000</year><fpage>390</fpage><lpage>398</lpage><comment>IEEE</comment></mixed-citation></ref><ref id="B2"><mixed-citation publication-type="journal"><name><surname>Langmead</surname><given-names>B</given-names></name><name><surname>Trapnell</surname><given-names>C</given-names></name><name><surname>Pop</surname><given-names>M</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name><etal/><article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title><source>Genome Biol</source><year>2009</year><volume>10</volume><issue>3</issue><fpage>R25</fpage><pub-id pub-id-type="doi">10.1186/gb-2009-10-3-r25</pub-id><pub-id pub-id-type="pmid">19261174</pub-id></mixed-citation></ref><ref id="B3"><mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>R</given-names></name><name><surname>Yu</surname><given-names>C</given-names></name><name><surname>Li</surname><given-names>Y</given-names></name><name><surname>Lam</surname><given-names>TW</given-names></name><name><surname>Yiu</surname><given-names>SM</given-names></name><name><surname>Kristiansen</surname><given-names>K</given-names></name><name><surname>Wang</surname><given-names>J</given-names></name><article-title>SOAP2: an improved ultrafast tool for short read alignment</article-title><source>Bioinformatics</source><year>2009</year><volume>25</volume><issue>15</issue><fpage>1966</fpage><lpage>1967</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btp336</pub-id><pub-id pub-id-type="pmid">19497933</pub-id></mixed-citation></ref><ref id="B4"><mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>H</given-names></name><name><surname>Durbin</surname><given-names>R</given-names></name><article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title><source>Bioinformatics</source><year>2009</year><volume>25</volume><issue>14</issue><fpage>1754</fpage><lpage>1760</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id><pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation></ref><ref id="B5"><mixed-citation publication-type="journal"><name><surname>Vezzi</surname><given-names>F</given-names></name><name><surname>Del Fabbro</surname><given-names>C</given-names></name><name><surname>Tomescu</surname><given-names>AI</given-names></name><name><surname>Policriti</surname><given-names>A</given-names></name><article-title>rNA: a fast and accurate short reads numerical aligner</article-title><source>Bioinformatics</source><year>2012</year><volume>28</volume><fpage>123</fpage><lpage>124</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btr617</pub-id><pub-id pub-id-type="pmid">22084252</pub-id></mixed-citation></ref><ref id="B6"><mixed-citation publication-type="journal"><name><surname>Policriti</surname><given-names>A</given-names></name><name><surname>Tomescu</surname><given-names>AI</given-names></name><name><surname>Vezzi</surname><given-names>F</given-names></name><article-title>A randomized Numerical Aligner (rNA)</article-title><source>J Comput Syst Sci</source><year>2012</year><volume>78</volume><issue>6</issue><fpage>1868</fpage><lpage>1882</lpage><pub-id pub-id-type="doi">10.1016/j.jcss.2011.12.007</pub-id></mixed-citation></ref><ref id="B7"><mixed-citation publication-type="journal"><name><surname>Takenaka</surname><given-names>Y</given-names></name><name><surname>Seno</surname><given-names>S</given-names></name><name><surname>Matsuda</surname><given-names>H</given-names></name><article-title>Perfect Hamming code with a hash table for faster genome mapping</article-title><source>BMC genomics</source><year>2011</year><volume>12</volume><issue>Suppl 3</issue><fpage>S8</fpage><pub-id pub-id-type="doi">10.1186/1471-2164-12-S3-S8</pub-id><pub-id pub-id-type="pmid">22369457</pub-id></mixed-citation></ref><ref id="B8"><mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>R</given-names></name><name><surname>Li</surname><given-names>Y</given-names></name><name><surname>Kristiansen</surname><given-names>K</given-names></name><name><surname>Wang</surname><given-names>J</given-names></name><article-title>SOAP: short oligonucleotide alignment program</article-title><source>Bioinformatics</source><year>2008</year><volume>24</volume><issue>5</issue><fpage>713</fpage><lpage>714</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btn025</pub-id><pub-id pub-id-type="pmid">18227114</pub-id></mixed-citation></ref><ref id="B9"><mixed-citation publication-type="other"><name><surname>Cole</surname><given-names>R</given-names></name><name><surname>Gottlieb</surname><given-names>LA</given-names></name><name><surname>Lewenstein</surname><given-names>M</given-names></name><article-title>Dictionary matching and indexing with errors and don't cares</article-title><source>Proceedings of the thirty-sixth annual ACM symposium on Theory of computing</source><year>2004</year><fpage>91</fpage><lpage>100</lpage><comment>ACM</comment></mixed-citation></ref><ref id="B10"><mixed-citation publication-type="book"><name><surname>Chan</surname><given-names>HL</given-names></name><name><surname>Lam</surname><given-names>TW</given-names></name><name><surname>Sung</surname><given-names>WK</given-names></name><name><surname>Tam</surname><given-names>SL</given-names></name><name><surname>Wong</surname><given-names>SS</given-names></name><article-title>A linear size index for approximate pattern matching</article-title><source>Combinatorial Pattern Matching</source><year>2006</year><publisher-name>Springer</publisher-name><fpage>49</fpage><lpage>59</lpage></mixed-citation></ref><ref id="B11"><mixed-citation publication-type="book"><name><surname>Policriti</surname><given-names>A</given-names></name><name><surname>Prezza</surname><given-names>N</given-names></name><article-title>Hashing and Indexing: Succinct Data Structures and Smoothed Analysis</article-title><source>Algorithms and Computation</source><year>2014</year><publisher-name>Springer</publisher-name><fpage>157</fpage><lpage>168</lpage></mixed-citation></ref><ref id="B12"><mixed-citation publication-type="journal"><name><surname>Ewing</surname><given-names>B</given-names></name><name><surname>Hillier</surname><given-names>L</given-names></name><name><surname>Wendl</surname><given-names>MC</given-names></name><name><surname>Green</surname><given-names>P</given-names></name><article-title>Base-calling of automated sequencer traces usingPhred. I. Accuracy assessment</article-title><source>Genome research</source><year>1998</year><volume>8</volume><issue>3</issue><fpage>175</fpage><lpage>185</lpage><pub-id pub-id-type="doi">10.1101/gr.8.3.175</pub-id><pub-id pub-id-type="pmid">9521921</pub-id></mixed-citation></ref><ref id="B13"><mixed-citation publication-type="other"><name><surname>Prezza</surname><given-names>N</given-names></name><name><surname>Del Fabbro</surname><given-names>C</given-names></name><name><surname>Vezzi</surname><given-names>F</given-names></name><name><surname>De Paoli</surname><given-names>E</given-names></name><name><surname>Policriti</surname><given-names>A</given-names></name><article-title>ERNE-BS5: aligning BS-treated sequences by multiple hits on a 5-letters alphabet</article-title><source>Proceedings of the ACM Conference on Bioinformatics, Computational Biology and Biomedicine</source><year>2012</year><fpage>12</fpage><lpage>19</lpage><comment>ACM</comment></mixed-citation></ref></ref-list></back></article>